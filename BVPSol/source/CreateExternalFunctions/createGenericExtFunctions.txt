###############################################################################
#
# @path BVPSol/source/createGenericExtFunctions.txt
#
# @brief create procedures which contained RHS, derivatives and boundary conditions
#        for the correspondent problem and method
#
# @param anBVPSys: of type DAESys,
#                  method name
#       
# @return fortan files
#
# @revision
# 2012-01-16 written by dka
#
###############################################################################
  createGenericExtFunctions:= proc(anBVPSys::DAESys,
				   methodName::name,
				   phaseCondition,
                                   indPhaseCondVarible::integer)
  
  local FCN, DFDY, NumDynVars, NumCritPars, RHSOriginalBVP, JacOriginalBVP,
        i1, i2, CritParsNames, DynVarsNames, NamesConventionForFortran,
        extBVPSys, NumExtDynVars, ExtRHSBVP, ExtDynVarsNames, ExtJacBVP,
        ExtNamesConventionForFortran, FSUB, DFSUB, GSUB, BoundCond, offsetInd,
        BoundCondJac, DGSUB, indNum;
  
  #
  # for both 'period' and 'twpbvp' create fortran file that contain
  # RHS of original BVP problem and its jacobian
  #
    NumDynVars:=nops(anBVPSys["ODEs"]);
    NumCritPars:=nops(anBVPSys["Parameters"]);
    RHSOriginalBVP:=map(rhs,anBVPSys["ODEs"]);
    
    CritParsNames:= map(lhs,anBVPSys["Parameters"]);
    DynVarsNames:=anBVPSys["DynVars"];
    
    JacOriginalBVP:= [seq(
            [seq(
              diff(RHSOriginalBVP[i1], DynVarsNames[i2]),
              i2= 1..NumDynVars)],
            i1= 1..NumDynVars)];
    
    NamesConventionForFortran:=[seq(DynVarsNames[i1]=Z[i1],i1=1..NumDynVars),
                                seq(CritParsNames[i2]=TRPAR[i2],i2=1..NumCritPars)
				];

    RHSOriginalBVP:=subs(NamesConventionForFortran,RHSOriginalBVP);
    JacOriginalBVP:=subs(NamesConventionForFortran,JacOriginalBVP);
    
    FCN:= subs(        
            NumDynVarsToBeSubs=  NumDynVars,
            NumCritParsToBeSubs= NumCritPars,
            RHSToBeSubs=         RHSOriginalBVP, 
            eval(CreateExternalFunctions:-Templates:-FCNTemplate)
     );
     
    DFDY:= subs(        
            NumDynVarsToBeSubs=  NumDynVars,
            NumCritParsToBeSubs= NumCritPars,
            JacToBeSubs=         JacOriginalBVP, 
            eval(CreateExternalFunctions:-Templates:-DFDYTemplate)
     );
  
  
    codegen[fortran](
            FCN, 
            filename= "fortranrhs.f",
            precision= double
          );
      
    codegen[fortran](
            DFDY, 
            filename= "fortranjac.f",
            precision= double
          );
  #
  # for method 'twpbvp' create BVP problem extended by constants for period 
  # and left hand side boundary value conditions (they derivatives equal to zero),
  # i.e period and boundary conditions are teated as unknown ODE variables
  #  
  if (methodName='twpbvp') 
  then
    extBVPSys:=table();
    extBVPSys["ODEs"]:=[seq(lhs(anBVPSys["ODEs"][i1])=PeriodVarNew*rhs(anBVPSys["ODEs"][i1]),i1=1..NumDynVars),
			`PeriodVarNew'`=0,
			seq(`RightCoord[i2]'`=0,i2=1..NumDynVars-1)];
    extBVPSys["DynVars"]:=[op(DynVarsNames),
			   PeriodVarNew,
			   seq(RightCoord[i2],i2=1..NumDynVars-1)];   
    extBVPSys["Parameters"]:=anBVPSys["Parameters"];
    extBVPSys["AEs"]:=anBVPSys["AEs"];
    extBVPSys["AlgVars"]:=anBVPSys["AlgVars"];
    extBVPSys["ExplicitAEs"]:=anBVPSys["ExplicitAEs"];
    
    NumExtDynVars:=nops(extBVPSys["ODEs"]);
    ExtRHSBVP:=map(rhs,extBVPSys["ODEs"]);
    
    ExtDynVarsNames:=extBVPSys["DynVars"];
    
    ExtJacBVP:= [seq(
            [seq(
              diff(ExtRHSBVP[i1], ExtDynVarsNames[i2]),
              i2= 1..NumExtDynVars)],
            i1= 1..NumExtDynVars)];
    
    ExtNamesConventionForFortran:=[seq(ExtDynVarsNames[i1]=Z[i1],i1=1..NumExtDynVars),
                                   seq(CritParsNames[i2]=TRPAR[i2],i2=1..NumCritPars)
				  ];

    ExtRHSBVP:=subs(ExtNamesConventionForFortran,ExtRHSBVP);
    ExtJacBVP:=subs(ExtNamesConventionForFortran,ExtJacBVP);

    
    FSUB:= subs(        
            NumExtDynVarsToBeSubs= NumExtDynVars,
            NumCritParsToBeSubs  = NumCritPars,
            RHSExtToBeSubs       = ExtRHSBVP, 
            eval(CreateExternalFunctions:-Templates:-FSUBTemplate)
     );
     
    DFSUB:= subs(        
            NumExtDynVarsToBeSubs= NumExtDynVars,
            NumCritParsToBeSubs  = NumCritPars,
            JacExtToBeSubs       = ExtJacBVP, 
            eval(CreateExternalFunctions:-Templates:-DFSUBTemplate)
     );
  
  
    codegen[fortran](
            FSUB, 
            filename= "extrhs.f",
            precision= double
          );
      
    codegen[fortran](
            DFSUB, 
            filename= "extjac.f",
            precision= double
          );
   #
   # create functions for bondary value conditions and its jacobian
   #
    BoundCond:=[subs(ExtNamesConventionForFortran,phaseCondition)];
    offsetInd:=0;
    for indNum from 1 to NumDynVars do
      if (indNum=indPhaseCondVarible) 
      then offsetInd:=1;
      else BoundCond:=[op(BoundCond),Z[indNum]-Z[indNum+NumDynVars+1-offsetInd]];
      end if;
    end do;
    BoundCond:=[op(BoundCond),op(BoundCond)];
   
    GSUB:= subs(        
            NumExtDynVarsToBeSubs= NumExtDynVars,
            NumCritParsToBeSubs  = NumCritPars,
            BoundCondToBeSubs    = BoundCond, 
            eval(CreateExternalFunctions:-Templates:-GSUBTemplate)
     );
   
    codegen[fortran](
            GSUB, 
            filename= "boundcond.f",
            precision= double
          );
   
   
    BoundCondJac:= [seq(
            [seq(
              diff(BoundCond[i1], Z[i2]),
              i2= 1..NumExtDynVars)],
            i1= 1..NumExtDynVars)];
   
    DGSUB:= subs(        
            NumExtDynVarsToBeSubs= NumExtDynVars,
            NumCritParsToBeSubs  = NumCritPars,
            BoundJacToBeSubs     = BoundCondJac, 
            eval(CreateExternalFunctions:-Templates:-DGSUBTemplate)
     );
   
    codegen[fortran](
            DGSUB, 
            filename= "boundjac.f",
            precision= double
          );
   
    
  end if;

  RETURN();
  
  end proc; # createGenericExtFunctions 
