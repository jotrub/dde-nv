######################################################################
#
# @path BVPSOL/source/CreateInstance.txt 
#
# @param  DAESys,
#         WorkingDir, directory into which bvpsol files will be written
#                     when compiling and at runtime
#         nodes, number of nodes in multi-shooting procedure,
#         list of compilled objects obtaned from TIDES,
#         optional argument method name which is 'period' [Deuflhard,1984] 
#                  or 'twpbvp' [Capper&Cash,2007] (by default the method 
#                  is set to 'period')  
#         optional phase condition (nesessary to be defined for the method 
#                  'twpbvp', if not given by default is set to x1(0)=0)        
#
# @return  procedure which starts bvpsol
#
# @notes (i) list of compilled objects obtaned from TIDES should
#            contain path to "calltides.o" and corresponding 
#            system file, e.g., "scott.o"
#        (ii) for convenience only simple phase conditions are accepted,
#             i.e only conditions of type 'varible_i-constant' 
#
# @revision
#   2011-01-18 written by dka
#
######################################################################
  CreateInstance:=proc(anBVPSys::DAESys,
                       WorkingDir::string,
                       nodes::integer,
                       objNames::list(string)
                       #optional methodName
                       #optional phaseCondition
                       )

    local bvpsol, BVPSolInstance, methodName, phaseCondition,
	  indPhaseCondVarible, logicPhaseVarPresent; 
    
     #
     # prepare working dir
     # refuse to work if file cwrap_bvpsol1.so already exists
     #
        if Aux:-FileOperations:-fileExists(cat(WorkingDir, "/cwrap_bvpsol1.so"))
        then
          error(
            "in working dir, %1, a maple wrapper file named "
            "cwrap_bvpsol1.so already exists", WorkingDir
          );
        end if; 
    
    #
    # extract method name for a BVP solver if it is given
    #
    
    if (nargs>4)
    then 
      methodName:=args[5];
    else
      methodName:=period;  
    end if; 
    
    #
    # validate input for the method name
    #
    if not ((methodName='period') or (methodName='twpbvp'))
      then error("Method name should be 'period' or 'twpbvp'",methodName);
    end if; 
    
    
    #
    # extract phase condition
    #
    if (nargs>5)
    then 
      phaseCondition:=args[6];
    else
      phaseCondition:=anBVPSys["DynVars"][1];  
    end if; 
    
    #
    # check if the phase condition is given in the form 'varible_i-constant' 
    #
    logicPhaseVarPresent:=validatePhaseCondition(anBVPSys,phaseCondition);
    if(logicPhaseVarPresent=false)
      then error("Phase condition should be given in form 'var_i-constant'",phaseCondition);
    end if;

    #
    # get index of varible_i in the phase condition
    #
    indPhaseCondVarible:=getPhaseConditionIndex(anBVPSys,phaseCondition);
    
    
    # 
    # substiture explicit functions intro anBVPSys
    #
    anBVPSys := Aux:-SystemClasses:-subsExplicitAEsIntoDAESys(anBVPSys);
     
    #
    # prepare interface to PERIOD or TWPBVP
    #

      try:
        bvpsol:= createSharedObject(
          WorkingDir,
          anBVPSys,
          objNames,
          methodName,
          phaseCondition,
          indPhaseCondVarible
        );
      catch:
	printf("CreateSharedObject failed, \n");
        printf("  error thrown was %q\n", lastexception);
        printf("  attempting to continue CreateInstance\n");
      end try; 


    #
    # create instance of simple wrapper
    #

      printf("creating instance of interface\n"); 
      
      try:
        BVPSolInstance:= SubsIntoSimpleWrapper(
          anBVPSys, 
          bvpsol,
          WorkingDir,
          nodes,
          indPhaseCondVarible
	);
      catch:
	printf("SubsIntoSimpleWrapper failed, \n");
        printf("  error thrown was %q\n", lastexception);
        printf("  attempting to continue CreateInstance\n");      
      end try;
      

    RETURN(eval(BVPSolInstance));

  end proc; #CreateInstance






