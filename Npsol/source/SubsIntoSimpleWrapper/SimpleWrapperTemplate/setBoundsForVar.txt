###############################################################################
#
# NPSOL/source/SubsIntoSimpleWrapper/SimpleWrapperTemplate/setBoundsForVar
#
# returns current variable bounds in the form list(name= number..number)
#
# revision history:
# 030419 addec check for multiple entries in first argument
# 030109 changes to take into account scaling of variables; user can now
#   pass bounds in terms of physical variables; these are scaled if 
#   scaling is used in instance; 
# 030108 written by mmo
#
###############################################################################
setBoundsForVar:= proc(
  ReqBounds::{
    name=EvalsToFloat..EvalsToFloat,
    list(name=EvalsToFloat..EvalsToFloat)
  }
)

  local NewBounds, Pos, ValsNewBounds, i1, VarIndex, D, c, NewLower, 
    NewUpper, NamesReqBounds, item; 

  #
  # convert input argument to standard type list
  #
    if not
      type(ReqBounds, list)
    then
      NewBounds:= [ReqBounds];
    else
      NewBounds:= ReqBounds;
    end if; 

  #
  # refuse to work if entries occur more than once 
  #
    NamesReqBounds:= map(lhs, ReqBounds);
    for item in NamesReqBounds do
      if
        numboccur(item, NamesReqBounds)> 1
      then
        error("symbol %1 occurs more than once in list of bounds", item);
      end if;
    end do; 

  #
  # find position of requested variables in list of variables of self
  #
    Pos:= array(1..nops(NewBounds));
    for i1 from 1 to nops(NewBounds) do
    
      try
        Pos[i1]:= Aux:-ListOperations:-getPosOfLHSin( 
          lhs(NewBounds[i1]),
          RequiredVars
        );
      catch:
        printf(
          "could not find requested variable %q in list of NLP variables\n",
          lhs(NewBounds[i1])
        ); 
        error # throw last error
      end try;

    end do;
    Pos:= convert(Pos, list);

  #
  # loop over positions, set lower and upper bounds
  #
    if
      ScalingOn= true
    then
      #
      # extract lower and upper bounds
      #
        ValsNewBounds:= map(rhs, NewBounds); 
        NewLower:= [seq(
          op(1, evalf(ValsNewBounds[i1])),
          i1= 1..nops(ValsNewBounds)
        )];
        NewUpper:= [seq(
          op(2, evalf(ValsNewBounds[i1])),
          i1= 1..nops(ValsNewBounds)
        )]; 
      #
      # scale physical to scaled
      #    
        D:= Scaling:-getD();
        c:= Scaling:-getc();
        for i1 from 1 to nops(Pos) do
          VarIndex:= Pos[i1];
          BL_swnpsol[VarIndex]:= D[VarIndex]* NewLower[i1]- c[VarIndex];
          BU_swnpsol[VarIndex]:= D[VarIndex]* NewUpper[i1]- c[VarIndex]; 
        end do; 
          
    else # ScalingOn= false

      ValsNewBounds:= map(rhs, NewBounds); 
      for i1 from 1 to nops(Pos) do
        VarIndex:= Pos[i1];
        BL_swnpsol[VarIndex]:= op(1, evalf(ValsNewBounds[i1]));
        BU_swnpsol[VarIndex]:= op(2, evalf(ValsNewBounds[i1])); 
      end do; 
    end if; 

  return();

end proc; 
