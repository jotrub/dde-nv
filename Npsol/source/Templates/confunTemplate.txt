    ###------------------------------------------------------------------------
    #
    # template function confunTemplate, local to NPSOL
    #
    # In CreateNPSOLexternalFunctions actual information from anNLP is 
    # substituted into this template
    #
    # revision history:
    #   021217 introduced common block for parameters; deleted code
    #     which assigned values to par; 
    #   021127 introduced dummy explicit AE;
    #   021125 template now receives explicit algebraic equations; 
    #   010424 introduced dummy parameter which allows to use template
    #     for nlps without any parameters - mmo 
    #   0011xx written by mmo
    ###------------------------------------------------------------------------
    confunTemplate:= proc(
      mode::integer,
      ncnln::integer,
      n::integer,
      nrowj::integer,
      needc::integer,
      x,                          # type declared below
      c,                          # type declared below
      cjac,                       # type declared below
      nstate::integer
    )
    
      global par; # codegen will create common block
      local
        n_in_confun,
        ncnln_in_confun,
        z; 
    
      declare(
        par= array(
          1..(NumParsToBeSubs+1), # one dummy par is always introduced
          numeric                 # this allows to use the same 
        ),                        # template in case the NLP to be
                                  # substituted does not have any
                                  # parameters

        x= array(
          1..NumVarsToBeSubs,
          numeric
        ),
  
        c= array(
          1..NumConsToBeSubs,
          numeric
        ),
  
        cjac= array(
          1..NumConsToBeSubs,
          1..NumVarsToBeSubs,
          numeric
        ),
  
        n_in_confun= integer,
  
        ncnln_in_confun= integer,

        z= array(
          1..NumEAEsToBeSubs+ 1,
          numeric
        )
      ); 
  
      #
      # check for errors
      #
        n_in_confun:= NumVarsToBeSubs;
        if
          not(n_in_confun= n)
        then
          ERROR(`Error in confun: n differs from number of variables`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 
  
        ncnln_in_confun:= NumConsToBeSubs;
        if
          not(ncnln_in_confun= ncnln)
        then
          ERROR(`Error in confun: ncnln differs from number of equations`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 
  
      #
      # calculate explicit algebraic equations
      #
        z:= [EAEsToBeSubs, 0]; 

      #
      # calculate right hand sides of equations
      #
        c:= ConstraintsToBeSubs; 
  
      #
      # calculate Jacobian
      #
        cjac:= array(          #  note: for some reason, codegen/fortran
          1..NumConsToBeSubs,  #  does not work if the array (rather
          1..NumVarsToBeSubs,  #  than its entries in ListListToBeSubs)
          ListListToBeSubs     #  is substituted; this trick solves
        );                     #  the problem
              
      RETURN();
    
    end proc: #ConfunTemplate
