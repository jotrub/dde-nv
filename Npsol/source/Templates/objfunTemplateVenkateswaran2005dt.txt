    ###------------------------------------------------------------------------
    #
    # template function objfunTemplate, local to NPSOL
    #
    # below actual information from anNLP is substituted into
    # this template
    #
    # revision history:
    #  2008-06-11 written by dka  
    #
    ###------------------------------------------------------------------------
    objfunTemplate:= proc(
      mode::integer,
      n::integer,
      x, 
      objf::float,
      objgrad, 
      nstate::integer
    )

      global par;   
      local n_in_objfun, z, cs, i, erainv, cainv, score; 
  
      declare(
        par= array(
          1..(NumParsToBeSubs+ 1), # see note concerning dummy
          numeric                  # parameter in ConfunTemplate above
        ),
  
        x= array(
          1..NumVarsToBeSubs,
          numeric
        ),

        objgrad= array(
          1..NumVarsToBeSubs,
          numeric
        ),

        n_in_objfun= integer,

        z= array(
          1..NumEAEsToBeSubs+ 1,
          numeric
        ),

       cs=array(1..10000,1..9,numeric),
      
       i= integer, 
       erainv= float, 
       cainv= float, 
       score= float
        
      ); 
  
      #
      # check for errors
      #
        n_in_objfun:= NumVarsToBeSubs;
        if
          not(n_in_objfun= n)
        then
          ERROR(`Error in confun: n differs from number of variables`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 
      
      #
      # calculate explicit algebraic equations
      #
        z:= [EAEsToBeSubs, 0]; 

      #
      # calculate objective function
      #

   
   cs[1,1]:=0;
   cs[1,2]:=0;
   cs[1,3]:=0;
   cs[1,4]:=0;
   cs[1,5]:=0;
   cs[1,6]:=0;
   cs[1,7]:=0;
   cs[1,8]:=0;
   cs[1,9]:=0;
   
   erainv := 0; 
   cainv := 0; 

  for i from 1 to 9000 do
   cs[i+1, 1] := cs[i, 1]+x[3]*(par[1]-cs[i, 1])*par[3];
   cs[i+1, 2] := cs[i, 2]+x[3]*(par[4]*cs[i, 1]-cs[i, 2]);
   cs[i+1, 3] := cs[i, 3]+x[3]*(cs[i, 1]+cs[i, 2]-cs[i, 3]);
   cs[i+1, 4] := cs[i, 4]+x[3]*(x[2]*(cs[i, 2]-cs[i, 4])+x[1]*(cs[i, 3]-cs[i, 5])-cs[i, 8]);
   cs[i+1, 5] := cs[i, 5]+x[3]*(cs[i, 6]-par[2]);
   cs[i+1, 6] := cs[i, 7];
   cs[i+1, 7] := cs[i, 8];
   cs[i+1, 8] := cs[i, 9];
   cs[i+1, 9] := x[2]*(cs[i, 2]-cs[i, 4])+x[1]*(cs[i, 3]-cs[i, 5]);

   cainv := ((cs[i,9]-par[1])^2)*(i-1); 
   erainv := erainv+cainv;

   end do;


   score := erainv;

        objf:= score;
  
      #
      # calculate gradient of objective function
      #
      # objgrad:= GradToBeSubs;
              
      RETURN();
  
    end proc: #objfunTemplate
