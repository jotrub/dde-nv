###############################################################################
#
# @path BVPOpt/InternalNVVars/calcDerForCritParamFortran.txt
# 
# @brief calculates non-trivial derivatives for constraint and objective fucntion
#        templates, e.g. diff(FX_ij,k)=FXP_ijk
# 
# @param constraint, for which non-trivial derivatives will be calculates
#        index of the critical parameter for differentiation in the list of uncertain parameters,
#        internal variables of the normal vector system,
#        number of ODEs in the system for which NV were construncted,
#        number of uncertain parameters in the system
#
# @notes it is assumed that non-trivial partial derivatives obtained from linear terms,
#        which is, in general, true for the normal vector constraints
#
# @authors dka
#
# @revision
# 2011-11-19 written by dka
#
###############################################################################
calcDerForCritParamFortran:=proc(constr::term, 
                                 indexOfDeriv::integer,
                                 internalVars::list(name),
                                 numOfDynEqns,
                                 numOfUncParam)

local listOfPartialDerivs, i1, constrDeriv, counter1, i, j, k, f_x,
      f_alpha, internalVarsDerivsToSubsList, listForFxx, f_xx, listForFxAlpha,
      f_xalpha, f_T, f_xT, viCoeff, constrDerivMinVi;

#
# list partial derivatives with respect to internal variables of the normal vector system
# (by construction of NV systems this list will not contain internal variables themself)
#
listOfPartialDerivs:= [seq(diff(constr, internalVars[i1]),
			    i1= 1..nops(internalVars))];

#
# construct list of partial derivatives for internal variables of the normal vector system
#
internalVarsDerivsToSubsList:=[];

# add values for diff(Fx,alpha_k)

f_x:= Matrix(numOfDynEqns,numOfDynEqns,symbol='Fx');

for i from 1 to numOfDynEqns do
  for j from 1 to numOfDynEqns do
    internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_x[i,j]=FXP[i,j,indexOfDeriv]];
  end do;
end do;


# add values for diff(f_alpha,alpha_k) 

f_alpha:= Matrix(numOfDynEqns,numOfUncParam,symbol='Fp');

for i from 1 to numOfDynEqns do
  for j from 1 to numOfUncParam do
    internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_alpha[i,j]=FPP[i,j,indexOfDeriv]];
  end do;
end do;


# add values for  diff(f_xx,alpha_k) 

listForFxx := []; 
for i to numOfDynEqns do 
  listForFxx := [op(listForFxx), convert(Matrix(numOfDynEqns, numOfDynEqns, symbol = 'Fxx[i]'), listlist)] 
end do: 
f_xx := Array(listForFxx);


for i from 1 to numOfDynEqns do
  for j from 1 to numOfDynEqns do
    for k from 1 to numOfDynEqns do
      internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_xx[i,j,k]=FXXP[i,j,k,indexOfDeriv]];
    end do;
  end do;
end do;


# add values for diff(f_xalpha,alpha_k)
 
listForFxAlpha := []; 
for i to numOfDynEqns do 
  listForFxAlpha := [op(listForFxAlpha), convert(Matrix(numOfDynEqns, numOfUncParam, symbol = 'Fxp[i]'), listlist)] 
end do: 
f_xalpha := Array(listForFxAlpha);


for i from 1 to numOfDynEqns do
  for j from 1 to numOfDynEqns do
    for k from 1 to numOfUncParam do
      internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_xalpha[i,j,k]=FXPP[i,j,k,indexOfDeriv]];
    end do;
  end do;
end do;


#
# diff(f_xT,alpha_k) and diff(f_xxT,alpha_k)

f_T:=Vector(numOfDynEqns,symbol='Ft');

for i from 1 to numOfDynEqns do
#  internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_T[i]=F0P[i,indexOfDeriv]];
   internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_T[i]=0];
end do; 


f_xT:=Matrix(numOfDynEqns,numOfDynEqns,symbol='Fxt');


for i from 1 to numOfDynEqns do
  for j from 1 to numOfDynEqns do
#    internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_xT[i,j]=J0P[i,j,indexOfDeriv]];
   internalVarsDerivsToSubsList:=[op(internalVarsDerivsToSubsList),f_xT[i,j]=0];
  end do;
end do;

#
# final constraint derivative
#

constrDeriv:=0;
for counter1 from 1 to nops(internalVars) do
  constrDeriv:=constrDeriv+listOfPartialDerivs[counter1]*subs(internalVarsDerivsToSubsList,internalVars[counter1]);
end do;

constrDeriv:=simplify(constrDeriv);
viCoeff:=0;
for i from 1 to numOfDynEqns do
viCoeff:=viCoeff+v1[i]*coeff(constrDeriv,v1[i]);
end do;
for i from 1 to numOfDynEqns do
viCoeff:=viCoeff+v2[i]*coeff(constrDeriv,v2[i]);
end do;
constrDerivMinVi:=simplify(constrDeriv-viCoeff);
constrDeriv:=constrDerivMinVi+viCoeff; 
  
return constrDeriv;

end proc; 

