###########################################################################
#
# @path template function objfunRobotSpeedTemplate
#
# @brief template for calculating the speed of the passive walking robot [Goswami1996]
#
# @notes  (1) end result is scaled with factor 10000
#         (2) in anNLP["ObjfunTemplatePath"] should be given path to this template
#         (3) anNLP["ObjFunParameters"] names of parameters in objective function
#             are specified (by default take fist n_alpha parameters) 
# @revision
# 2013-07-11 written by dka
###########################################################################
    objfunTemplate:= proc(
      mode::integer,
      n::integer,
      x, 
      objf::float,
      objgrad, 
      nstate::integer
    )

      global par;   
      local 
        n_in_objfun, 
        z,
        X0,    # init point
        P,     # period
        OBJPAR, # parameters
        NPHASE,# index of phase condition variable
        n1,    # dimension of ODEs
        m1,    # number of nodes where BVP solution is calculated 
        n2,    # number of parameters
        n3,    # output print option
        Y,     # BVP solution
        FM,    # eigenvalues of BVP
        FX,    # jacobian of BVP
        POUT,  # period of BVP solution
        IFAIL, # if IFAIL>0 then BVP solution is found 
        ERRY,  # if ERRY=0 the BVP solution is constant
        FP,    # derivatives matrix f_Alpha
        FXP,   # derivatives matrix f_xAlpha
        FXX,   # derivatives matrix f_xx
        FPP,   # derivatives matrix f_AlphaAlpha
        FXXP,  # derivatives matrix f_xxAlpha
        FXPP,  # derivatives matrix f_xAlphaAlpha;
        i1;    # counter 
  
      declare(
        par= array(
          1..(NumParsToBeSubs+ 1), # see note concerning dummy
          numeric                  # parameter in ConfunTemplate above
        ),
  
        x= array(
          1..NumVarsToBeSubs,
          numeric
        ),

        objgrad= array(
          1..NumVarsToBeSubs,
          numeric
        ),

        n_in_objfun= integer,

        z= array(
          1..NumEAEsToBeSubs+ 1,
          numeric
        ),
        
        X0=array(1..NumDynVarsToBeSubs,numeric),
        P=numeric,
        OBJPAR=array(1..NumCritParsToBeSubs,numeric),
        NPHASE=integer,
        
        n1= integer,
        m1= integer,
        n2= integer,
        n3= integer,
        
        Y=array(1..NumDynVarsToBeSubs,1..NumOfNodesToBeSubs,numeric),
        FM=array(1..NumDynVarsToBeSubs,1..2,numeric),
        FX=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        POUT=numeric,
        IFAIL=integer,
        ERRY=numeric,
        
        FP=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXX=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        FPP=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXXP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXPP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,1..NumCritParsToBeSubs,numeric),
        
        i1=integer
      ); 
  
      #
      # check for errors
      #
        n_in_objfun:= NumVarsToBeSubs;
        if
          not(n_in_objfun= n)
        then
          ERROR(`Error in confun: n differs from number of variables`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 


      #
      # set initial point for BVP problem solution
      #
      
        X0:=array(1..NumDynVarsToBeSubs,initX0ToBeSubs);

      # set initial guess for period
        
        P:=initPToBeSubs;
      
      # critical parameters values  
        
	OBJPAR:=array(1..NumCritParsToBeSubs,indsObjVarsToBeSubs);	
        
        n1:=NumDynVarsToBeSubs; # dimension of ODEs
        m1:=NumOfNodesToBeSubs; # number of nodes where BVP solution is calculated
        n2:=NumCritParsToBeSubs; # number of parameters
        n3:=-1; # output print option

      # calculate BVP solution and its partial derivatives 
   
        CALLPERIOD(n1,m1,n3,X0,P,n2,OBJPAR,Y,FM,POUT,IFAIL,ERRY,FP,FXP,FXX,FX,NPHASE,FPP,FXXP,FXPP);

      
      #
      # calculate explicit algebraic equations
      #
        z:= [EAEsToBeSubs, 0]; 

      #
      # calculate objective function
      # (average value of the second variable)
      #
       objf:=2*sin(0.5*(Y[2,1]-Y[1,1]))/POUT;
       
       objf:=-objf;
      # to force NPSOL to find more precise optimal value we introduce a factor 10000 of original objective 
       objf:=1000000*objf;
  
      #
      # calculate gradient of objective function
      # (gradients are ommited)
      #
      #  objgrad:= GradToBeSubs;
      
      # print objective params info and objective function value
      printParObjFun(n2,OBJPAR,objf);
      
      if (IFAIL <> 0) then error "FAILED IN OBJECTIVE";
      end if;
              
      RETURN();
  
    end proc: #objfunTemplate
