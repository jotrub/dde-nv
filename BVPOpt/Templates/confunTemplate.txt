###########################################################################
#
# @path template function confunTemplate, local to BVPOpt
#
# @brief In CreateExternalFunctions actual information from anNLP is 
#        substituted into the template
#
# @revision
#   2011-12-11 written by dka
###########################################################################
    confunTemplate:= proc(
      mode::integer,
      ncnln::integer,
      n::integer,
      nrowj::integer,
      needc::integer,
      x,                          # type declared below
      c,                          # type declared below
      cjac,                       # type declared below
      nstate::integer
    )
    
      global par; # codegen will create common block
      local
        n_in_confun,
        ncnln_in_confun,
        z,
        X0,    # init point
        P,     # period
        TRPAR, # critical parameters
        NPHASE,# index of phase condition variable
        n1,    # dimension of ODEs
        m1,    # number of nodes where BVP solution is calculated 
        n2,    # number of parameters
        n3,    # output print option
        Y,     # BVP solution
        FM,    # eigenvalues of BVP
        FX,    # jacobian of BVP
        POUT,  # period of BVP solution
        IFAIL, # if IFAIL>0 then BVP solution is found 
        ERRY,  # if ERRY=0 the BVP solution is constant
        FP,    # derivatives matrix f_Alpha
        FXP,   # derivatives matrix f_xAlpha
        FXX,   # derivatives matrix f_xx
        FPP,   # derivatives matrix f_AlphaAlpha
        FXXP,  # derivatives matrix f_xxAlpha
        FXPP,  # derivatives matrix f_xAlphaAlpha
        X0S,   # starting point of BVP solution
        F0,    # derivatives matrix f_xT
        J0,    # derivatives matrix f_xxT
        T1,    # value of T in the fist node (=0 by default)
        F0P,    # derivatives matrix f_xTP
        J0P,    # derivatives matrix f_xxTP
        i1;
          
      declare(
        par= array(
          1..(NumParsToBeSubs+1), # one dummy par is always introduced
          numeric                 # this allows to use the same 
        ),                        # template in case the NLP to be
                                  # substituted does not have any
                                  # parameters

        x= array(
          1..NumVarsToBeSubs,
          numeric
        ),
  
        c= array(
          1..NumConsToBeSubs,
          numeric
        ),
  
        cjac= array(
          1..NumConsToBeSubs,
          1..NumVarsToBeSubs,
          numeric
        ),
  
        n_in_confun= integer,
  
        ncnln_in_confun= integer,

        z= array(
          1..NumEAEsToBeSubs+ 1,
          numeric
        ),
        
        X0=array(1..NumDynVarsToBeSubs,numeric),
        P=numeric,
        TRPAR=array(1..NumCritParsToBeSubs,numeric),
        NPHASE=integer,
        
        n1= integer,
        m1= integer,
        n2= integer,
        n3= integer,
        
        Y=array(1..NumDynVarsToBeSubs,1..NumOfNodesToBeSubs,numeric),
        FM=array(1..NumDynVarsToBeSubs,1..2,numeric),
        FX=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        POUT=numeric,
        IFAIL=integer,
        ERRY=numeric,
        
        FP=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXX=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        FPP=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXXP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXPP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,1..NumCritParsToBeSubs,numeric),
        
        X0S=array(1..NumDynVarsToBeSubs,numeric),
        F0=array(1..NumDynVarsToBeSubs,numeric),
        J0=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        F0P=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        J0P=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        T1=numeric,
        
        i1=integer
      ); 
  
      #
      # check for errors
      #
        n_in_confun:= NumVarsToBeSubs;
        if
          not(n_in_confun= n)
        then
          ERROR(`Error in confun: n differs from number of variables`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 
  
        ncnln_in_confun:= NumConsToBeSubs;
        if
          not(ncnln_in_confun= ncnln)
        then
          ERROR(`Error in confun: ncnln differs from number of equations`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 
  
      #
      # calculate explicit algebraic equations
      #
        z:= [EAEsToBeSubs, 0]; 


      # set initial guess for period
        
        P:=initPToBeSubs;
        
      #
      # set initial point for BVP problem solution
      #
      
        X0:=array(1..NumDynVarsToBeSubs,initX0ToBeSubs);

      
      # critical parameters values  
        
	TRPAR:=array(1..NumCritParsToBeSubs,indsCritVarsToBeSubs);
	
      # index of the variable involved in the phase condition 
        
        NPHASE:=indPhaseToBeSubs;
        
        n1:=NumDynVarsToBeSubs; # dimension of ODEs
        m1:=NumOfNodesToBeSubs; # number of nodes where BVP solution is calculated 
        n2:=NumCritParsToBeSubs; # number of parameters
        n3:=-1; # output print option

      # calculate BVP solution and its partial derivatives 
   
        CALLPERIOD(n1,m1,n3,X0,P,n2,TRPAR,Y,FM,POUT,IFAIL,ERRY,FP,FXP,FXX,FX,NPHASE,FPP,FXXP,FXPP);
	
        
      # set starting point of BVP solution trajectory
      
      for i1 from 1 to NumDynVarsToBeSubs do
	X0S[i1]:=Y[i1,1];
      end do;
              
      # calculate f_T=F0 and f_xT=J0, where T is the period of the solution

      T1:=0.0;
      FCN(T1,X0S,F0,TRPAR);
      DFDY(T1,X0S,J0,TRPAR);
      
      # calculate f_TAlpha=F0P and f_xTAlpha=J0P
      funcF0P(X0S,F0P,TRPAR);
      funcJ0P(X0S,J0P,TRPAR);


      #
      # calculate right hand sides of equations
      #
        c:= ConstraintsToBeSubs; 
  
      #
      # calculate Jacobian
      # (comment for calculating gradients mumerically)
      # cjac:= array(1..NumConsToBeSubs,1..NumVarsToBeSubs,ListListToBeSubs);                    
              
      RETURN();
    
    end proc: #ConfunTemplate
