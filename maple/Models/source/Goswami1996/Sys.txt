###############################################################################
#
# @path Models/source/Goswami1996/Sys.txt
#
# @brief Implements a passive waalking robot model from Goswami1996
# 
# @notes Provides AESys, switching condition, and Poincare map
#
# @authors dka
#
# @revision history
# 2013-08-27 Created by dka 
#
###############################################################################
Sys:= module()

  local aSys, M1, N1, gV1, M1m1, Part2Mgen, Qm, Qp, Mgen1, switchConds, Qpm1, Qgen,
  Tr1, TransformVars1, aPoincSect;

  export
    getSys, 
    getSwitchingConditions,
    getPoincareSect;
    
# 
# The model of a passive walking robot model reads as
# M1(theta)*theta''+N1(theta,theta')*theta'+gV1(theta)=0.
# 
# It can be rewritten as system of equations
# d/dt(theta)=theta',
# d/dt(theta')=-M1(theta)^(-1)*[N1(theta,theta')*theta'+gV1],
# where [theta, theta']=[tn, ts, dn, ds]
#

  M1:=Matrix([[beta^2, -(1+beta)*beta*cos(2*alpha)],[-(1+beta)*beta*cos(2*alpha),(1+beta)^2*(mu+1)+1]]);
  M1m1:=LinearAlgebra[MatrixInverse](M1);
  N1:=Matrix([[0,(1+beta)*beta*ds*sin(ts-tn)],[-(1+beta)*beta*dn*sin(ts-tn),0]]);
  gV1:=Vector([g*beta*sin(tn),-((mu+1)*(1+beta)+1)*g*sin(ts)]);
  Part2Mgen:=N1.Vector([dn,ds])+gV1/a;
  Mgen1:=-M1m1.Part2Mgen;
  
  aSys:= table();

  aSys["ODEs"]:= [`tn'` =dn, 
		  `ts'` =ds,
		  `dn'`= Mgen1[1],
		  `ds'`= Mgen1[2]];
  
  aSys["ExplicitAEs"]:= [beta=1,g=9.8,a=1/(1+beta),alpha=(ts-tn)/2];
  aSys["DynVars"]:= [tn, ts, dn, ds];
  aSys["Parameters"]:= [mu=2, anglePoincare=3];
  
  aSys["AlgVars"]:= [];
  aSys["AEs"]:= [];
  
#
# switching condition
# W(alpha)=[[J,0],[0,H(alpha)]], where
# J=[[1,0],[0,1]] and H(alpha)=Qp(alpha)^(-1)*Qm(alpha)
#  
  
  Qm:=Matrix([[-beta, -beta+(mu*(1+beta)^2+2*(1+beta))*cos(2*alpha)],[0,-beta]]);
  Qp:=Matrix([[beta*(beta-(1+beta)*cos(2*alpha)),(1+beta)*((1+beta)-beta*cos(2*alpha))+1+mu*(1+beta)^2],[beta^2,-beta*(1+beta)*cos(2*alpha)]]);
  
  Qpm1:=LinearAlgebra[MatrixInverse](Qp);
  Qgen:=subs(aSys["ExplicitAEs"],Qpm1.Qm);
  
  Tr1:=Matrix([[0,1,0,0],[1,0,0,0],[0,0,Qgen[1,1],Qgen[1,2]],[0,0,Qgen[2,1],Qgen[2,2]]]);
  TransformVars1:=Tr1.Vector(aSys["DynVars"]);
  
  switchConds:=[ts,tn,TransformVars1[3],TransformVars1[4]];
  
#
# Poincare section
#  
  aPoincSect:=ts+tn+2*evalf(anglePoincare*Pi*(1/180));  

  #------------------------------------------------------------
  #
  # getSys
  #
  #------------------------------------------------------------
  getSys:= proc()
    return(eval(aSys)); 
  end proc;
  
  #------------------------------------------------------------
  #
  # getSwitchingConditions
  #
  #------------------------------------------------------------
  getSwitchingConditions:= proc()
    return(eval(switchConds)); 
  end proc;
  
  #------------------------------------------------------------
  #
  # getPoincareSect
  #
  #------------------------------------------------------------
  getPoincareSect:= proc()
    return(eval(aPoincSect)); 
  end proc;     

end module; 

