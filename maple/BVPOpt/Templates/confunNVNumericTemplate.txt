###########################################################################
#
# @path template function confunTemplate, local to BVPOpt
#
# @brief In CreateExternalFunctions actual information from anNLP is 
#        substituted into the template
#
# @revision
#   2011-12-11 written by dka
###########################################################################
    confunTemplate:= proc(
      mode::integer,
      ncnln::integer,
      n::integer,
      nrowj::integer,
      needc::integer,
      x,                          # type declared below
      c,                          # type declared below
      cjac,                       # type declared below
      nstate::integer
    )
    
      global par; # codegen will create common block
      local
        n_in_confun,
        ncnln_in_confun,
        z,
        X0,    # init point
        P,     # period
        TRPAR, # critical parameters
        NPHASE,# index of phase condition variable
        n1,    # dimension of ODEs
        m1,    # number of nodes where BVP solution is calculated 
        n2,    # number of parameters
        n3,    # output print option
        Y,     # BVP solution
        FM,    # eigenvalues of BVP
        FX,    # jacobian of BVP
        POUT,  # period of BVP solution
        IFAIL, # if IFAIL>0 then BVP solution is found 
        ERRY,  # if ERRY=0 the BVP solution is constant
        FP,    # derivatives matrix f_Alpha
        FXP,   # derivatives matrix f_xAlpha
        FXX,   # derivatives matrix f_xx
        FPP,   # derivatives matrix f_AlphaAlpha
        FXXP,  # derivatives matrix f_xxAlpha
        FXPP,  # derivatives matrix f_xAlphaAlpha
        X0S,   # starting point of BVP solution
        F0,    # derivatives matrix f_xT
        J0,    # derivatives matrix f_xxT
        T1,    # value of T in the fist node (=0 by default)
        F0P,    # derivatives matrix f_xTP
        J0P,    # derivatives matrix f_xxTP
        i1,
        i2,
        i3,
        i4,
        PEPS,  # parameters that collects last parameter values for calculating tangent space
        TPNEW, # actual parameters for calculating tangent space
        FXEPS, # jacobian that corresponed parameters for calculating tangent space
        FXTMP; # temporary variable for storing the jacobian
          
      declare(
        par= array(
          1..(NumParsToBeSubs+1), # one dummy par is always introduced
          numeric                 # this allows to use the same 
        ),                        # template in case the NLP to be
                                  # substituted does not have any
                                  # parameters

        x= array(
          1..NumVarsToBeSubs,
          numeric
        ),
  
        c= array(
          1..NumConsToBeSubs,
          numeric
        ),
  
        cjac= array(
          1..NumConsToBeSubs,
          1..NumVarsToBeSubs,
          numeric
        ),
  
        n_in_confun= integer,
  
        ncnln_in_confun= integer,

        z= array(
          1..NumEAEsToBeSubs+ 1,
          numeric
        ),
        
        X0=array(1..NumDynVarsToBeSubs,numeric),
        P=numeric,
        TRPAR=array(1..NumCritParsToBeSubs,numeric),
        NPHASE=integer,
        
        n1= integer,
        m1= integer,
        n2= integer,
        n3= integer,
        
        Y=array(1..NumDynVarsToBeSubs,1..NumOfNodesToBeSubs,numeric),
        FM=array(1..NumDynVarsToBeSubs,1..2,numeric),
        FX=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        POUT=numeric,
        IFAIL=integer,
        ERRY=numeric,
        
        FP=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXX=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        FPP=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXXP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        FXPP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,1..NumCritParsToBeSubs,numeric),
        
        X0S=array(1..NumDynVarsToBeSubs,numeric),
        F0=array(1..NumDynVarsToBeSubs,numeric),
        J0=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        F0P=array(1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        J0P=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,1..NumCritParsToBeSubs,numeric),
        T1=numeric,
        
        i1=integer,
        i2=integer,
        i3=integer,
        i4=integer,
        
        PEPS=array(1..NumCritParsToBeSubs-1,numeric),
        TPNEW=array(1..NumCritParsToBeSubs,numeric),
        FXEPS=array(1..NumCritParsToBeSubs-1,1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric),
        FXTMP=array(1..NumDynVarsToBeSubs,1..NumDynVarsToBeSubs,numeric)
      ); 
  
      #
      # check for errors
      #
        n_in_confun:= NumVarsToBeSubs;
        if
          not(n_in_confun= n)
        then
          ERROR(`Error in confun: n differs from number of variables`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 
  
        ncnln_in_confun:= NumConsToBeSubs;
        if
          not(ncnln_in_confun= ncnln)
        then
          ERROR(`Error in confun: ncnln differs from number of equations`);
          # note: do not change to Maple6 syntax of error command,
          #   codegen/fortran cannot deal with new syntax
          #   this is probably a bug in Maple6 - mmo
        end if; 
  
      #
      # calculate explicit algebraic equations
      #
        z:= [EAEsToBeSubs, 0]; 


      # set initial guess for period
        
        P:=initPToBeSubs;
        
      #
      # set initial point for BVP problem solution
      #
      
        X0:=array(1..NumDynVarsToBeSubs,initX0ToBeSubs);

      
      # critical parameters values  
        
	TRPAR:=array(1..NumCritParsToBeSubs,indsCritVarsToBeSubs);
	PEPS:=array(1..NumCritParsToBeSubs-1,indEpsCritParamsToBeSubs);
	
      # index of the variable involved in the phase condition 
        
        NPHASE:=indPhaseToBeSubs;
        
        n1:=NumDynVarsToBeSubs; # dimension of ODEs
        m1:=NumOfNodesToBeSubs; # number of nodes where BVP solution is calculated 
        n2:=NumCritParsToBeSubs; # number of parameters
        n3:=-1; # output print option
        
      # print critical params info for constraints
        printParConFun(n2,TRPAR);

      # calculate BVP solution and its partial derivatives 
   
        CALLPERIOD(n1,m1,n3,X0,P,n2,TRPAR,Y,FM,POUT,IFAIL,ERRY,FP,FXP,FXX,FX,NPHASE,FPP,FXXP,FXPP);
	
	for i1 from 1 to (NumCritParsToBeSubs-1) do
	  
	  for i2 from 1 to (NumCritParsToBeSubs-1) do
	    TPNEW[i2]:=TRPAR[i2];
	  end do;
	  
	  TPNEW[i1]:=TPNEW[i1]+EpsToBeSubs;
	  TPNEW[NumCritParsToBeSubs]:=PEPS[i1];
	  
	  CALLPERIOD(n1,m1,n3,X0,P,n2,TPNEW,Y,FM,POUT,IFAIL,ERRY,FP,FXP,FXX,FXTMP,NPHASE,FPP,FXXP,FXPP);
	  
	  for i3 from 1 to NumDynVarsToBeSubs do
	    for i4 from 1 to NumDynVarsToBeSubs do
	      FXEPS[i1,i3,i4]:=FXTMP[i3,i4];
	    end do;
	  end do;
        
        end do;
              

      #
      # calculate right hand sides of equations
      #
        c:= ConstraintsToBeSubs; 
  
      
      if (IFAIL <> 0) then error "FAILED IN CONSTRAINTS";
      end if;
                         
              
      RETURN();
    
    end proc: #ConfunTemplate
