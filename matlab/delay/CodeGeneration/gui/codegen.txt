#initialisation
restart; 
#define paths
_ModulesDirectory:="path2";
#load modules 
 cat(_ModulesDirectory, "/Aux/Aux.mpl");
 read(cat(_ModulesDirectory, "/Aux/Aux.mpl")): 
 read(cat(_ModulesDirectory, "/AugSys2/AugSys2.mpl")): 

#define system
Sys["DynVars"]:=[x1]; 
Sys["Parameters"]:=[alpha1=321]; 
Sys["AEs"]:=[];
Sys["ODEs"]:=[`x1'` = equation2]; 
Sys["DelVars"]:=[x1tau1, x1tau2]; 
Sys["AlgVars"]:=[];
Sys["ExplicitAEs"]:=[State1=x1, Pa1=alpha1, State1tau1=x1tau1, State1tau2=x1tau2];
Sys["Delays"]:=[tau[1]=Delay1, tau[2]=D2];
 
#insert fixed parameters
#
Sys:=Aux:-SystemClasses:-subsExplicitAEsIntoDAESys(Sys);
# look for errors
Aux:-SystemClasses:-listOfErrorsInDDESys(Sys, strict);
# define normal vector system
AugSys:=AugSys2:-SdDelayBif:-ModFoldNV:-CreateModFoldNVSys(Sys,[ alpha1],4441):-getSys();

#pick relevant equations of Normal Vextor System
manifoldEq:=[]:
for i from 1 by 1 to 3 do
ithRhs:=rhs(AugSys["Equations"][i]);
for jj from 1 by 1 to nops(Sys["DynVars"]) do
ithRhs:=subs(Sys["DynVars"][jj]=x[jj],ithRhs): # ...states, ...
end do:
for jj from 1 by 1 to nops(Sys["Parameters"]) do
ithRhs:=subs(lhs(Sys["Parameters"][jj])=alpha[jj],ithRhs): # and parameters...
end do:
manifoldEq:=[op(manifoldEq),ithRhs]:
end do:
#create frame for code generation
Procedure4CodeGen:=proc(x, alpha ,w )
m;
end proc;
ManifoldEquation:=subs([m=manifoldEq],eval(Procedure4CodeGen));
# generate C code
CodeGeneration:-C(ManifoldEquation,returnvariablename="residuum",defaulttype=numeric,output="Manifold.c",deducetypes=false);

#pick relevant equations of Normal Vextor System
manifoldEq:=[]:
for i from 4 by 1 to nops(AugSys["Equations"]) do
ithRhs:=rhs(AugSys["Equations"][i]);
for jj from 1 by 1 to nops(Sys["DynVars"]) do 
ithRhs:=subs(Sys["DynVars"][jj]=x[jj],ithRhs): # ...states, ...
end do:
for jj from 1 by 1 to nops(Sys["Parameters"]) do 
ithRhs:=subs(lhs(Sys["Parameters"][jj])=alpha[jj],ithRhs): # and parameters...
end do:
manifoldEq:=[op(manifoldEq),ithRhs]:
end do:
# create frame for code generation
Procedure4CodeGen:=proc(x, alpha, w1, v1, g1, u, r)
m;
end proc;
ManifoldEquation:=subs([m=manifoldEq],eval(Procedure4CodeGen));
# generate C code
CodeGeneration:-C(ManifoldEquation,returnvariablename="residuum",defaulttype=numeric,output="NV.c",deducetypes=false);
#get dde equations
dderhs:=[]; # create space for dde right hand side
for ii from 1 by 1 to nops(Sys["DynVars"]) do
ithRhs:=rhs(Sys["ODEs"][ii]): # get one entry and replace...
for jj from 1 by 1 to nops(Sys["DynVars"]) do
ithRhs:=subs(Sys["DynVars"][jj]=x[jj],ithRhs): # ...states, ...
end do:
for jj from 1 by 1 to nops(Sys["DelVars"]) do
ithRhs:=subs(Sys["DelVars"][jj]=xtau[jj],ithRhs); # ...delayed states,...
end do:
for jj from 1 by 1 to nops(Sys["Parameters"]) do
ithRhs:=subs(lhs(Sys["Parameters"][jj])=alpha[jj],ithRhs): # and parameters...
end do:
dderhs:=[op(dderhs),ithRhs]; # and concatenate it with the existing entries
end do:
# create frame for code generation
Procedure4CodeGen:=proc(x,xtau,alpha)
m;
end proc;
DDErightHandSide:=subs([m=dderhs],eval(Procedure4CodeGen));
# generate C code
CodeGeneration:-C(DDErightHandSide,returnvariablename="xdot",defaulttype=numeric,output="DDE.c",deducetypes=false);