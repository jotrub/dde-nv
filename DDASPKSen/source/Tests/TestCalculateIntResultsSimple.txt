######################################################################
#
#procedure TestCalculateIntResultsSimple.txt
#
#description: Test if DDASPKSen works with variable input. 
#	      _EnvWorkingDir and _EnvModuleDir has to be set in the
#	      calling sheet. 
#
#input: none
#
#output: true => test was succesful
#	 false => test has failed
#
#
#revision history:
#080526 created by tqu
#######################################################################

TestCalculateIntResultsSimple := proc()

  local 
   aDAESys,
   x1Data, 
   x2Data, 
   timePoints,
   test1Suceeded,
   test2Suceeded,
   actResults,
   initialVars,
   initialTime,
   DDASPKproc,
   DglSys,
   sol,	
   initConds0,
   pars0,
   sol0,
   tableOfSolution,
   tableOfDiffs,
   tableOfAnalyticalValues,
   parsNames,
   senName,
   p,
   actVar,
   parameter,
   actDiff,
   subsedDiff,
   subsedVar,
   allIndices,
   numResults,
   name,
   actNumValues,
   actAnalyticalValues,
   i,
   numValue,
   analyticalValue;

  currentdir(_EnvWorkingDir):
  test1Suceeded:=true:
  initialVars:=[2,1];	
  initialTime:=0;
  
  #
  #prepare a directory to store the instance of DDASPKSen	
  #
   currentdir();
   try:
     system("rm -r tmp");
   end:

  #
  #read modules needed
  #
   read(cat(_EnvModulesDir, "ModelPack/source/ModelPack.mpl")):
   read(cat(_EnvModulesDir, "DDASPKSen/source/DDASPKSen.mpl")):
   read(cat(_EnvModulesDir, "Adifor/source/ADIFOR.mpl")):


  #
  #define simple test systen
  #
   aDAESys:=ModelPack:-NewDAESys():
   aDAESys[ODEs] := [
     `x1'` =a1*x1+input,
     `x2'` =a2*x2
   ];
   aDAESys[Parameters] := [a1=-1, a2=-2, input=0];
   aDAESys[DynVars] := [x1, x2];
   aDAESys[AEs] := [];
   aDAESys[AlgVars] := [];

  #
  #ckeck if directory for DDASPKSen is already available
  #	
   if
     ModelPack:-DirExists("tmp")
   then
     error("temporary directory ./tmp needed to run test already exists")
   else  
       mkdir("tmp")
   end if;
   
  #
  #create instance of DDASPKsen
  #
   DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, "./tmp", [a1, a2], 'adifor'):

  #	      
  #set initial values, initial time, and parameter values and initialize DDASPKproc
  #
   DDASPKproc:-SetVars(initialVars);
   DDASPKproc:-SetInitialTime(initialTime);
   DDASPKproc:-Init();

   
  #
  #create Results with CalculateIntResults.txt
  # 
   timePoints:= [seq(i, i=0..5,0.1)];
   numResults:= DDASPKproc:-CalculateIntResults(timePoints[2..-1]);

  #
  #create analytical solution
  #
   DglSys:= {
     diff(x1(t), t)= a1* x1(t),
     diff(x2(t), t)= a2* x2(t),
     x1(initialTime)= x10,
     x2(initialTime)= x20
   };
   sol:= dsolve(
     DglSys, 
     {x1(t), x2(t)}
   );
   initConds0:= [
     x10= initialVars[1],
     x20= initialVars[2]
   ];
   pars0:= [
     a1= -1,
     a2= -2
   ];
   sol0:= subs(
     initConds0,
     sol
   );
   tableOfSolution:=table();
   tableOfDiffs:=table();
   tableOfAnalyticalValues:=table();
   parsNames:=map(lhs,pars0):
   
   for p from 1 to nops(sol0) do :
       actVar:=op(0,lhs(sol0[p]));
       tableOfSolution[actVar]:=rhs(sol0[p]);
              
       #calculate sensitivities
       for parameter in parsNames do:
	 actDiff:=diff(tableOfSolution[actVar], parameter);
         subsedDiff:= subs(pars0, initConds0, actDiff);
	 senName:=cat('d',actVar,'d',parameter);
	 tableOfDiffs[senName]:=subsedDiff;
	 tableOfAnalyticalValues[senName]:= [seq(eval(subsedDiff), t=0..5, 0.1)];
       end do:        
       
       #substitute values into analytical solution
       subsedVar:= subs(pars0, initConds0, tableOfSolution[actVar]);

       tableOfAnalyticalValues[actVar]:= [seq(eval(subsedVar), t=0..5, 0.1)];
   end do:

  #
  #test if numerical results equal analytical ones
  #
   allIndices:= [indices(tableOfAnalyticalValues,nolist)];
   for name in allIndices do:
     actNumValues:=numResults:-GetAllValuesOfVariable(name);
     actAnalyticalValues:= tableOfAnalyticalValues[name];

     for i from 1 to nops(timePoints)do:
       numValue:= actNumValues[i];
       analyticalValue:= evalf(subs(t=timePoints[i],actAnalyticalValues[i]));         
       if 
	 (abs(numValue - analyticalValue) > 0.0001) 
       then
	 test1Suceeded := false;
	 print("Warning(Test1): failed");
       end if;
     end do:

   end do:
   
   return([test1Suceeded,numResults]);
  

end proc; #TestCalculateIntResultsSimple