###====================================================================
#
# @path DDASPKSen/CreateInstance.txt
#
# @brief exported procedure CreateInstance
#
# @param a DAEsys to be integrated
#
# @return module with methods which call ddaspk, 
#   see source/CreateInstance/SimpleWrapper.txt
#   for methods 
#
# @revision
#   2010-08-26 exchanged ussage of ModelPack to Aux - dka
#   091019 added missing local variable names, tqu
#   050222 appends InstanceCounter to file and external procedure names,
#     if Keyword 'SetFileName' and 'NoInterface' is set
#   040824 now returns changed DAESystem when KeyWord is 'NoInterface'
#   040809 added 'NoInterface' Keyword, which prevents creation of dll
#     and the run of define_external
#   040210 changed commands to extract names of variables,
#     parameters, etc., to check if aDAESys is in the
#     standard notation op(0... to op(1... -jge 
#   040205 changes to allow computations of sensitivities -jge
#   021126 added second argument to call to
#     SubsStandardNotationIntoDAESys; 
#   020410 changed treatment of optional arguments; this was done
#     to prepare for another optional arg apart from 'adifor'; additional
#     optional arg turned out to be obsolete; changes were kept to
#     allow for additional optional args later; 
#   020319 first argument, aDAESys, no longer needs to be in standard
#     notation; CreateInstance now substitutes standard notation, and
#     substitutions are included in file DAEsystem.m; 
#   020311 (1) changes to allow for parameter passing via RPAR from
#     maple to DDASPK, see CreateSharedObject for details
#   020303 (1) removed dir CreateInstance, since CreateInstance.txt no 
#     longer includes CreateInstance/SimpleWrapper.txt; 
#     CreateInstance/SimpleWrapper.txt is now included by 
#     SubsIntoSimpleWrapper; (2) CreateInstance does not instanciate
#     SimpleWrapper, but calls SubsIntoSimpleWrapper; reason for 
#     moving this part to a separate proc is to allow to reuse it
#     in new proc RestoreInstance
#   020301 (1) added check PrepareDirForDDASPK, (2) added adifor option,
#     see PITCON:-CreateInstance revision history for more detailed
#     description of all steps necessary to allow for use of adifor in
#     an existing module 
#   010810 written by mkl and mmo, modeled after corresponding NPSOL file
#
###=====================================================================
  CreateInstance:=proc(
    ReqDAESys::DAESys,
    WorkingDir::string,
    SenParameters::{name,list(name),name=EvalsToFloat, list(name=EvalsToFloat)}
    # optional arguments 'adifor', 'KeepEAEs','NoInterface', 'SetFileName'
  )

    local ddaspk, NEQtoBeSubs, LIWtoBeSubs, LRWtoBeSubs, NY, base,
      SimpleWrapper, INFO5toBeSubs, aDAESys, DAEsystem, NumParsInDAEsys,NumSenParsInDAESys,
      NewDAESys, NamesDynVars, NamesAlgVars, NamesExplicitAEs, InterfaceKeyword,
      NamesPars, NamesSenPars,KnownOpts, UnknownOpts, ReqOpts, NameOfJac, NameOfRes, SetEndOfFileName, Jac, Res;  

    #
    # Append New Entry SenPars in DAESys
    #
     InstanceCounter:= InstanceCounter + 1; 
     aDAESys:=appendSenParsToDAESys(ReqDAESys,SenParameters);

    #---------------------------------------------------------------------
    #
    # treat optional arguments
    #
    #----------------------------------------------------------------------
      KnownOpts:= ['adifor','NoInterface','SetFileName'];

      #
      # extract requested options, warn about unknown options
      #
        if 
          nargs>3
        then
          ReqOpts:= [args[4..-1]];
        else
          ReqOpts:= [];
        end if; 

        UnknownOpts:= convert(ReqOpts, set) minus convert(KnownOpts, set);
        if not
          UnknownOpts= {}      
        then
          WARNING(cat(
            "in DDASPK:-CreateInstance, requested options %1 are ",
            "not known. Known options are %2"), UnknownOpts, KnownOpts
          );
        end if;

      #
      # Set InterfaceKeyword
      #
        if
          member('NoInterface',ReqOpts)
        then
          InterfaceKeyword:='NoInterface';
        else
          InterfaceKeyword:='BuildInterface';
        end if;

      #
      # Set Filename Keyword
      #
	if
	  (member('SetFileName', ReqOpts)) and (InterfaceKeyword='NoInterface')
	then
	  SetEndOfFileName:= true;
	else
	  SetEndOfFileName:= false;
        end if;

      #
      # treat option adifor
      # 
        if 
          nargs> 3
        then
          if
            member('adifor', ReqOpts) # convert(args[3], string)= "adifor"
          then
            UseAdifor:= true; # note this is a local variable of module DDASPK
          end if;
        else
          UseAdifor:= false;  # note this is a local variable of module DDASPK
        end if; 
  
        #
        # make sure adifor is available if requested
        #
          if
            UseAdifor= true
          then
            if not
              type(ADIFOR, `module`)
            then
              error("option adifor not available as module ADIFOR is not defined"); 
            end if;
          end if; 

      #
      # check if calculation of sensitivities is requested
      #
         if
           member (["SenPars"],{indices(aDAESys)})
         then
           EvalSen := true;
         else
           EvalSen := false;
      # create Table Entry SenPars to avoid conflicts in other procedures  
           aDAESys["SenPars"]:=[];
         end if;
         
    #------------------------------------------------------------
    #
    # check for common errors
    #
    #------------------------------------------------------------
      #
      # error if requested working dir is already being used
      #
        if 
          prepareDirForDDASPK(WorkingDir)= false
        then 
          error("requested working dir %1 is already in use", WorkingDir);
        end if; 

      #
      # warn if system is given in standard notation
      # standard notation is no longer required for CreateInstance
      #
        NamesDynVars:= {seq(
          op(1, aDAESys["DynVars"][i1]),
          i1= 1..nops(aDAESys["DynVars"])
        )};

        NamesAlgVars:= {seq(
          op(1, aDAESys["AlgVars"][i1]),
          i1= 1..nops(aDAESys["AlgVars"])
        )};

        NamesExplicitAEs:= {seq(
          op(1, map(rhs, aDAESys["ExplicitAEs"])[i1]),
          i1= 1..nops(aDAESys["ExplicitAEs"])
        )};

        NamesPars:= {seq(
          op(1, aDAESys["Parameters"][i1]),
          i1= 1..nops(aDAESys["Parameters"])
        )};

        NamesSenPars:= {seq(
          op(1, aDAESys["SenPars"][i1]),
          i1= 1..nops(aDAESys["SenPars"])
        )};

        if 
          NamesDynVars= {y}
          and (NamesAlgVars= {y} or NamesAlgVars= {})
          and (NamesExplicitAEs= {z} or NamesExplicitAEs= {})
          and (NamesPars= {par} or NamesPars= {}
          and (NamesSenPars= {senpar}) or NamesPars={})
        then
          WARNING(
            "note that DDASPK:-CreateInstance() does not require system to be in standard notation"
          ); 
          NewDAESys:= aDAESys; 
        else
          NewDAESys:= Aux:-SystemClasses:-subsStandardNotationIntoDAESysSen(
            aDAESys,
            y
          ); 
        end if;

    #----------------------------------------------------------------------
    #
    # prepare interface to DDASPK, part 1
    #
    # create maple procs res and jac which encapsulate
    #   problem dependent function yprime for debugging sensitivity analysis
    #   
    #----------------------------------------------------------------------
      if
        SetEndOfFileName
      then
        Jac:=convert(cat('jac',InstanceCounter),name);
        Res:=convert(cat('res',InstanceCounter),name);
      else
        Jac:=convert('jac',name);
        Res:=convert('res',name);
      end if;

      NameOfJac:=convert(Jac,string);
      NameOfRes:=convert(Res,string);

      createExternalFunctions(
	eval(NewDAESys),
        Res,
	Jac
      );

    #----------------------------------------------------------------------
    #
    # prepare interface to DDASPK, part 2
    #
    # export maple procs res, jac to fortran files
    #   res.f, jac.f, resp. in WorkingDir
    # compile them
    # link them with DDASPK fortran source code and c-wrapper 
    # create maple proc ddaspk which provides interface to DDASPK
    #
    #----------------------------------------------------------------------

      NumParsInDAEsys:= nops(NewDAESys["Parameters"]);
      if
        EvalSen= true
      then
        NumSenParsInDAESys:=nops(NewDAESys["SenPars"]);
      else
        NumSenParsInDAESys:= 0;
      end if;
      ddaspk:= createSharedObject(
        NameOfRes,
        Res,
	NameOfJac,
        Jac,
        WorkingDir,
        NewDAESys,
        InterfaceKeyword
      );

    #----------------------------------------------------------------------
    #
    # prepare interface to DDASPK, part 3
    # 
    # substitute maple proc ddaspk into instance of wrapper
    #
    #----------------------------------------------------------------------
     if
       InterfaceKeyword='BuildInterface'
     then
      #
      # get back to physical names
      #
        DAEsystem:= subs(
          map(rhs= lhs, NewDAESys["Substitutions"]),
          eval(NewDAESys)
        ); 

        DAEsystem["Substitutions"]:= map(rhs= lhs, NewDAESys["Substitutions"]); 


      SimpleWrapper:= SubsIntoSimpleWrapper(
        DAEsystem,
        ddaspk
      );

    #----------------------------------------------------------------------
    #
    # save DAE system into working directory to allow for later recovery
    #
    #----------------------------------------------------------------------
      save(
        DAEsystem, 
        cat(WorkingDir, "/DAEsystem.m")
      ); 
 
      RETURN(eval(SimpleWrapper));

   else
   #
   # return aDAESys which contains entries [SenPars]
   #
      RETURN(eval(aDAESys));
   end if;

  end proc; #CreateInstance










