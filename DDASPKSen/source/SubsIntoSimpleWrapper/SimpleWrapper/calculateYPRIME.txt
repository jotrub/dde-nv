############################################################################
# 
# @path DDASPKSen/SubsIntoSimpleWrapper/SimpleWrapper/calculateYPRIME.txt
#
# @brief local method calculateYPRIME
#
# @param none
#
# @returs none
#
# @notes
#  side effects: for given SimpleWrapper:-y_vec,
#   calculate SimpleWrapper:-yprime_vec by evaluating ODEs in DAEsys
#   (1) remember that calculation of yprime to get residues of
#   DAEsys to zero is only possible because DAEsys[ODEs] are explicit
#   equations for yprime, remember that DDASPK can deal with DAE
#   systems which cannot be solved for yprime explicitly;
#   (2) unfortunately, call of to ListOfErrorsInDAEsys occurs
#   twice and cannot be avoided (ModelPack:-EvalODEsInDAESys
#   and ModelPack:-EvalExplicitAEsInDAESys called internally)
#
# @todo:
#   (1) avoid calling ListOfErrorsInDAESys, see note (2) above
#
# @revision
# 2010-08-26 exchanged ussage of ModelPack to Aux - dka
# 091019 added missing local variable names; tqu
# 050406 if initialization fails INFO_vec[11] is set to 1--> DDASPK initializes problem
# 050112 added try catch around initialization loop -jge
# 040910 only when [AEs] = [] yprime is calculated else DDASPK evaluates
#    yprime (INFO[11]=1) -jge
# xxxxxx written by mmo
#
############################################################################
        calculateYPRIME:= proc()

      local SubsList, yprime, aSys,dgdp,dgdy, dSdt, DimOldIWORK, i1, NewIWORK_vec;

          SubsList:= [
            seq(
              Sys["DynVars"][i1]= y_vec[i1],
              i1= 1..nops(Sys["DynVars"])
            ),
            seq(
              Sys["AlgVars"][i1]= y_vec[nops(Sys["DynVars"])+ i1],
              i1= 1..nops(Sys["AlgVars"])
            ),
            seq(
              lhs(Sys["Parameters"][i1])= rpar_vec[i1],
              i1= 1..nops(Sys["Parameters"])
            ),
            seq(
              lhs(Sys["SenPars"][i1])= senpar_vec[i1],
              i1= 1..nops(Sys["SenPars"])
            )
          ]:

    # initialise Vector
          yprime_vec:= Vector(
            1..NEQ, i1->0, datatype= float[8]
          );
    #
    # set yprime only if [AEs] are empty else let DDASPK evaluates consistent initial conditions
    #
         if
       Sys["AEs"] = []
         then
            try
              yprime:= Aux:-SystemClasses:-evalODEsInDAESys(
                 Sys,
                 SubsList
               );

        # set known values of yprime (without sensitivities)
              for i1 from 1 to nops(yprime) do
                yprime_vec[i1]:= yprime[i1];
              end do;

              aSys:=Aux:-SystemClasses:-subsExplicitAEsIntoDAESys(Sys):
              dgdp:=[seq(
                     [
                      seq(diff(rhs(aSys["ODEs"][i1]),lhs(Sys["SenPars"][i2])),i2=1..nops(Sys["SenPars"]))
                     ],i1=1..nops(aSys["ODEs"]))
                   ];
              dgdy:=[seq(diff(rhs(aSys["ODEs"][i1]),aSys["DynVars"][i1]),i1=1..nops(aSys["ODEs"]))]:
              dSdt:=[seq
                   (
                     [
                      seq(dgdy[i2]*y_vec[nops(Sys["DynVars"])+(i1-1)*nops(Sys["DynVars"])+i2]
                          + dgdp[i2,i1], i2=1..nops(Sys["DynVars"]))
                     ], i1=1..nops(Sys["SenPars"])
                   )
                 ]:
              dSdt:= evalf(subs(
                       [op(aSys["Parameters"]),
                        op(Sys["SenPars"]),
                        seq(Sys["DynVars"][i1]=y_vec[i1],i1=1..nops(aSys["DynVars"]))
                      ],dSdt));

              for i1 from 1 to nops(Sys["SenPars"]) do
                for i2 from 1 to nops(Sys["DynVars"]) do
                  yprime_vec[nops(Sys["DynVars"])+(i1-1)*nops(Sys["DynVars"])+i2]:=dSdt[i1][i2];
                end do;
              end do;
           catch:
          printf("\n WARNING: Initialization failed \n");

         # set Info[11] to 1 --> initialization by DDASPK if CalculateYPRIME fails
          INFO_vec[11]:=1;

         # set LIW to 40+ 2*ny
          LIW:= 40 + 2*nops(Sys["DynVars"]);

         # augment IWORK_vec to vector(1..LIW)
              NewIWORK_vec := Vector(
              1..LIW, fill=0, datatype= integer[4]
             );
          DimOldIWORK:=LinearAlgebra[Dimension](IWORK_vec);
          for i1 from 1 to DimOldIWORK do
                NewIWORK_vec[i1]:=IWORK_vec[i1];
              end do;

          IWORK_vec:=NewIWORK_vec;

             # set IWORK[40+ 1..40+ n_x]=1 (DynVars)
              for i1 from 1 to nops(Sys["DynVars"]) do
                IWORK_vec[40+i1]:=1:
              end do:

           end try;
          end if;

          RETURN();

        end proc; # CalculateYPRIME
