######################################################################
#
# @path DDASPKSen/SubsIntoSimpleWrapper/SimpleWrapper/runIntWithDynConstraint.txt
#
# @brief  run integration from given initial 
#   point (set by SetVariables, SetParameters) for time
#   from initial to end time (set by SetInitialTime, 
#   SetEndTime), return Critical Point if Dynamic Constraint of
#   the type 0 < g(x,p) is no longer fulfilled
#
# @param none
#
# @return variables as functions of t, as calculated by
#   integration with RunInt and if integration is aborted the solution
#   at this point 
#
# @notes (i) former procedure RunInt is now called 
#   DoIntStep
#  
#
# @todo
#   (i) add option to tell code not to save values of 
#   variables determined by ExplicitAEs, but to save 
#   ExplicitAEs instead and teach data structure to calculate
#   and return these values when requested;
#
# @revision
# 2010-08-26 exchanged ussage of ModelPack to Aux - dka
# 050406 current value of t are substituted into ExplicitAEs - jge
# 050403 now saves array of critical points, which maximally violate the constraint
#   if optional argument 'maximum' is included
# 041108 introduced eps as tolerance for testing the dynamic constraint,
#   eps may be passed as optional argument, else it is set to 10^-3
# 041028 now returns empty critical point if integration finishes without
#   violating the constraint
# 041011 introduced check for dynamic constraints
# 040510 addded AlgVars to allow for integration of "real" DAE-Systems -jge 
# 030424 added printf command which informs user about 
#   every 100 integration steps; added Curve to local vars
# 021126 changes due to changes to ModelPack:-CreateCurve:
#   all non-point-like data is now passed in 2nd argument
#   OtherData; 
# 020726 calculated data is now returned in an object
#   of type Curve (constructor ModelPack:-CreateCurve)
# 020725 written by mmo
#
######################################################################
        runIntWithDynConstraint:= proc(
                      DynCon::term,
	              ReqEps::EvalsToFloat, #optional argument
		      ReqKeyword::name # optional argument must be maximum
             )

          local NumVarsInDAESys, Pars, ValuesExplicitVars, OtherData,
            SenNames,Curve, CurrentSubsList, ValueOfDynCon, OldValueOfDynCon, Eps,
            NumOfCriticalPoint, MaxDeviation, TableCriticalPoints, CurrentMaxPoint,
	    NumOfEntriesGreaterThanCurrentMin;

	   OldValueOfDynCon:=1e20; 
	   NumOfCriticalPoint:=0;
	   MaxDeviation:=false;
	   NumOfEntriesGreaterThanCurrentMin:=0;

	  #
	  # set Eps
	  #
           if
	     nargs>=2
           then
	     Eps:=ReqEps;
	   else
	     Eps:=1e-3;
	   end if;
          #
	  # check ReqKeyword
	  #
           if
	     nargs=3
	   then
	     if not
	       ReqKeyword='maximum'
             then
               printf("WARNING: Keyword %1 must be 'maximum', will be ignored", ReqKeyword);
	     else
	       MaxDeviation:=true;
	       TableCriticalPoints:=table();
             end if;
           end if;
            
          #
          # determine size of data table needed and call constructor
          #
            SenNames:=[seq(
                        seq(
                          cat(d,Sys["DynVars"][i1],d,lhs(Sys["SenPars"][i2])),
                            i2=1..nops(Sys["SenPars"])),
                            i1=1..nops(Sys["DynVars"]))];
            VarNames:= [
              op(Sys["DynVars"]),
	      op(Sys["AlgVars"]),
              op(SenNames),
              op(map(lhs, Sys["ExplicitAEs"]))
            ]; 
            NumVars:= nops(VarNames); 
            data:= table(); 
            for item in VarNames do
              data[item]:= array(1..MaxNumSteps); 
            end do;  
          
          #
          # reserve array for time of integration points
          #
            if
              member(t, VarNames)
            then
              error("name t must not be a variable names"); 
            end if; 

            data[t]:= array(1..MaxNumSteps); 

          #
          # loop to at most MaxNumSteps 
          #
            for i1 from 1 to MaxNumSteps do

              #
              # inform user about progress
              #
                if
                  i1 mod 100= 0
                then
                  printf(
                    "done with %d out of %d steps\n",
                    i1, MaxNumSteps
                  );
                end if; 

              #
              # do one integration step and extract current point
              #
                DdaspkStatus:= doIntStep();
                ValuesExplicitVars:= map(evalf,
                  map(rhs, getExplicitAEs())
                );
	        ValuesExplicitVars:=subs(t=getT(),ValuesExplicitVars);

                CurrentPoint:= [ 
                  op(getY()),
                  op(ValuesExplicitVars)
                ]; 


              #
              # put data into table, note that fixed order is
              # exploited
              #
                for i2 from 1 to nops(VarNames) do
                  item:= VarNames[i2]; 
                  data[item][i1]:= CurrentPoint[i2];
                end do; 
                data[t][i1]:= getT(); 

	      #	
	      # evaluate Dynamic Constraint for current values
	      # of state variables, fixed order is exploited
	      #
	        if
		  (not MaxDeviation and NumOfCriticalPoint=0)
		then   
    	          CurrentSubsList:=[
                     t = getT(),
                     seq(VarNames[i2]=CurrentPoint[i2],i2=1..nops(VarNames))
		    ];
  	          ValueOfDynCon:=evalf(subs(CurrentSubsList,DynCon));
	          if
	            ValueOfDynCon < - Eps
	          then
	            printf("The dynamic constraint %f is smaller than the tolerance %f \n",
                       ValueOfDynCon, Eps);		  
		    NumOfCriticalPoint:=NumOfCriticalPoint+1;
  	          end if;
		elif
              #
	      # find all maximal derivations
	      #
		  MaxDeviation
		then
    	          CurrentSubsList:=[
                     t = getT(),
                     seq(VarNames[i2]=CurrentPoint[i2],i2=1..nops(VarNames))
		    ];
  	          ValueOfDynCon:=evalf(subs(CurrentSubsList,DynCon));
		  if
                    (ValueOfDynCon > OldValueOfDynCon)
                  then
		    if 
		      NumOfEntriesGreaterThanCurrentMin=0
		    then
		      printf("The dynamic constraint %f is smaller than the tolerance %f \n",
                            OldValueOfDynCon, Eps);		  
   		      NumOfCriticalPoint:=NumOfCriticalPoint+1;
		      TableCriticalPoints[NumOfCriticalPoint]:=CurrentMaxPoint;
		    end if;
		    NumOfEntriesGreaterThanCurrentMin:=NumOfEntriesGreaterThanCurrentMin+1;
		    OldValueOfDynCon:=ValueOfDynCon;		   
		  end if;

	          if
	            ((ValueOfDynCon < - Eps) and (ValueOfDynCon < OldValueOfDynCon))
	          then
		    OldValueOfDynCon:=ValueOfDynCon;
		    CurrentMaxPoint:=CurrentSubsList;
		    NumOfEntriesGreaterThanCurrentMin:=0;
  	          end if;		 
	        end if;
              #
              # break out of loop if DDASPK refuses to integrate 
              # any further and set CurrentSubsList to []
              #
                if not
                  DdaspkStatus= 1
                then
		  if
		    NumOfCriticalPoint = 0
                  then
    		    CurrentSubsList:=[];
		    TableCriticalPoints:=table();
                  end if;
                  break;
                end if; 
            end do; 

            #
            # save number of points which actually have been 
            # calculated
            #
              OtherData:= [
                'NumPoints'= i1- 1
              ]; 

            #
            # save and print to screen status of DDASPK
            # 
              OtherData:= [
                op(OtherData),
                DDASPKstatus= DdaspkStatus
              ]; 

              print("RunInt finishes with DDASPK status ", DdaspkStatus); 

            #
            # save parameter values in table data (as one named list)
            #
              OtherData:= [
                op(OtherData),
                Parameters= GetParameters()
              ]; 

            #
            # call constructor for one-parametric curve
            #
              Curve:= Aux:-CreateCurve(
                data,
                OtherData
              ); 
	  if not
	    MaxDeviation
          then
   	    return(Curve,CurrentSubsList); 
	  else
   	    return(Curve,TableCriticalPoints);
	  end if;

        end proc; # RunIntWithDynConstraint

