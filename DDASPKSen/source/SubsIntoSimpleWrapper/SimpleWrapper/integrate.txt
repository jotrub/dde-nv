######################################################################
#
#  @path DDASPKSen/SubsIntoSimpleWrapper/SimpleWrapper/integrate.txt
#
#  @brief run integration from given initial 
#   point (set by SetVariables, SetParameters) for time
#   from initial to end time (set by SetInitialTime, 
#   SetEndTime), use at most number of points set by
#   SetMaxNumPoints. Only store and output the variable
#   values at the end time.
#
# @param (optional) boolean printInfo: true(default) => printouts of status and progress of
#				    integration is prompted
#			    false => printouts are supressed	    
#
# @return [x,y]: x is a table containing, the variable names as keys, and
#	  their value at the end time of integration as entries.
#	  The end time is stored under the key t. y contains the integer
#	  describing the status in which DDASPKSen has finished integration.
#
# @todo 
#   (i) add option to tell code not to save values of 
#   variables determined by ExplicitAEs, but to save 
#   ExplicitAEs instead and teach data structure to calculate
#   and return these values when requested jge;
#
# @revision
# 090305 added optional argument for printout of status and progress
#	 of integration, tqu.
# 080905 renamed procedure; former name RunInt.
#	 Only the points at the specified end time of integration
#	 are stored. This is not done in a curve anymore, but in
#	 a table. Changed due to memory problems, when used within
#	 IntegrateAtSpecificTimePoints. tqu
# 080523 added notes,tqu
# 050916 added AlgVars to SenNames -jge
# 050725 added SenParameters to OtherData -jge
# 050418 added NumPoints to list of local variables -jge
# 050406 current value of t are substituted into ExplicitAEs - jge
# 050217 changed names of sensitivities
# 041201 corrected indices for sensitivities
# 040510 addded AlgVars to allow for integration of "real" DAE-Systems -jge 
# 030424 added printf command which informs user about 
#   every 100 integration steps; added Curve to local vars
# 021126 changes due to changes to ModelPack:-CreateCurve:
#   all non-point-like data is now passed in 2nd argument
#   OtherData; 
# 020726 calculated data is now returned in an object
#   of type Curve (constructor ModelPack:-CreateCurve)
# 020725 written by mmo
#
######################################################################
        integrate:= proc(
#	  printInfo::boolean	  
	)

          local NumVarsInDAESys, Pars, ValuesExplicitVars, OtherData,
            SenNames,Curve, printInfo; 
	  
  	  #
	  #default setting of optional input argument	
	  # 
	   printInfo:= true;
  
	  #
	  #test for optional argument
	  #
	   if 
	     nargs =1
	   then
	     printInfo:= args[1]:
	     
	     if not
	       hastype(printInfo, boolean)
	     then
	       error("Optional input argument has to be of type boolean. You have inserted %1.", printInfo);
	     end if:
	   elif
	     nargs > 1
	   then
	     error("Too many optional arguments. Only one optional argument is allowed!");
	   end if:
 
          #
          # determine size of data table needed and call constructor
          #
            SenNames:=map(op,[seq([
	                 seq(
                           convert(cat(
                             d,convert(Sys["DynVars"][i2],string),
			     d,convert(lhs(Sys["SenPars"][i1]),string)),
                             name),
                           i2=1..nops(Sys["DynVars"])),
                         seq(
                           convert(cat(
                             d,convert(Sys["AlgVars"][i2],string),
			     d,convert(lhs(Sys["SenPars"][i1]),string)),
                             name),
                           i2=1..nops(Sys["AlgVars"]))
                         ],i1=1..nops(Sys["SenPars"]))
                      ]);

            VarNames:= [
              op(Sys["DynVars"]),
	      op(Sys["AlgVars"]),
              op(SenNames),
              op(map(lhs, Sys["ExplicitAEs"]))
            ]; 
            NumVars:= nops(VarNames); 

            data:= table(); 
          
          #
          # reserve array for time of integration points
          #
           if
             member(t, VarNames)
            then
              error("name t must not be a variable names"); 
            end if; 

          #
          # loop to at most MaxNumSteps 
          #
            for i1 from 1 to MaxNumSteps do
	      #
              # inform user about progress
              #
	       if
	         printInfo
	       then 
                if
                  i1 mod 100= 0
                then
                  printf(
                    "done with %d out of %d steps\n",
                    i1, MaxNumSteps
                  );
                end if; 
	       end if:	

              #
              # do one integration step and extract current point
              #
                DdaspkStatus:= doIntStep();
                ValuesExplicitVars:= map(evalf,
                  map(rhs, getExplicitAEs())
                );
		
		
		#printf("\n\nTEST: %a\n\n",Sys[ExplicitAEs]);
				
	      #
	      # subs current value of t into ExplicitAEs in case they depend on time
	      #
	        ValuesExplicitVars:=subs(t=getT(),ValuesExplicitVars);

				###TMP###
				#printf("ValuesExplicitVars %a \n",ValuesExplicitVars);
              	#########

                CurrentPoint:= [ 
                  op(getY()),
                  op(ValuesExplicitVars)
                ]; 
            
				###TMP###
				#printf("CurrentPoint %a \n",CurrentPoint);
				
				###TMP###
				#printf("data[t][i1] %a \n\n",data[t][i1]);
              	#########
              
			  #
              # break out of loop if DDASPK refuses to integrate 
              # any further
              #
                if not
                  DdaspkStatus= 1
                then 
		#
		#save data point, at which integration stops
		#
		  #########
		#
		# put data into table, note that fixed order is
		# exploited
		#
		  for i2 from 1 to nops(VarNames) do
		    item:= VarNames[i2]; 
		    data[item]:= CurrentPoint[i2];
		  end do; 
		  data[t]:= getT(); 

                  break;
                end if; 
            end do; 
	    
	    if
	      printInfo	 
	    then
              print("Integrate finishes with DDASPK status ", DdaspkStatus); 
	    end if:

	 return [data, DdaspkStatus];
	  
	 end proc; # integrate


 #stopat(Integrate);
